// Copyright (c) 2010 Satoshi Nakamoto
// Copyright (c) 2009-2016 The Bitcoin Core developers
// Distributed under the MIT software license, see the accompanying
// file COPYING or http://www.opensource.org/licenses/mit-license.php.

#include "rpc/misc.h"
//  TODO(GUILLE): CHECK THIS INCLUDES
// #include "base58.h"
// #include "clientversion.h"
// #include "config.h"
// #include "dstencode.h"
// #include "init.h"
// #include "net.h"
// #include "netbase.h"
// #include "rpc/blockchain.h"
// #include "rpc/server.h"
// #include "timedata.h"
// #include "txmempool.h"
// #include "util.h"
// #include "utilstrencodings.h"
// #include "validation.h"
// #ifdef ENABLE_WALLET
// #include "wallet/rpcwallet.h"
// #include "wallet/wallet.h"
// #include "wallet/walletdb.h"
// #endif
// #include "warnings.h"
#include <chain.h>
#include <clientversion.h>
#include <config.h>
#include <core_io.h>
#include <httpserver.h>
#include <key_io.h>
#include <logging.h>
#include <net.h>
#include <netbase.h>
#include <outputtype.h>
#include <rpc/blockchain.h>
#include <rpc/server.h>
#include <rpc/util.h>
#include <script/descriptor.h>
#include <timedata.h>
#include <util/check.h>
#include <util/strencodings.h>
#include <util/system.h>
#include <util/validation.h>
#include <validation.h>
#include <warnings.h>

#include <univalue.h>

#include <cstdint>
#ifdef HAVE_MALLOC_INFO
#include <malloc.h>
#endif

static UniValue validateaddress(const Config &config,
                                const JSONRPCRequest &request) {
    if (request.fHelp || request.params.size() != 1) {
        throw std::runtime_error(RPCHelpMan{
            "validateaddress",
            "\nReturn information about the given bitcoin address.\n",
            {
                {"address", RPCArg::Type::STR, RPCArg::Optional::NO,
                 "The bitcoin address to validate"},
            },
            RPCResult{
                "{\n"
                "  \"isvalid\" : true|false,       (boolean) If the address is "
                "valid or not. If not, this is the only property returned.\n"
                "  \"address\" : \"address\",        (string) The bitcoin "
                "address validated\n"
                "  \"scriptPubKey\" : \"hex\",       (string) The hex-encoded "
                "scriptPubKey generated by the address\n"
                "  \"isscript\" : true|false,      (boolean) If the key is a "
                "script\n"
                "}\n"},
            RPCExamples{
                HelpExampleCli("validateaddress",
                               "\"1PSSGeFHDnKNxiEyFrD1wcEaHr9hrQDDWc\"") +
                HelpExampleRpc("validateaddress",
                               "\"1PSSGeFHDnKNxiEyFrD1wcEaHr9hrQDDWc\"")},
        }
                                     .ToString());
    }

    CTxDestination dest =
        DecodeDestination(request.params[0].get_str(), config.GetChainParams());
    bool isValid = IsValidDestination(dest);

    UniValue ret(UniValue::VOBJ);
    ret.pushKV("isvalid", isValid);

    if (isValid) {
        if (ret["address"].isNull()) {
            std::string currentAddress = EncodeDestination(dest, config);
            ret.pushKV("address", currentAddress);

            CScript scriptPubKey = GetScriptForDestination(dest);
            ret.pushKV("scriptPubKey",
                       HexStr(scriptPubKey.begin(), scriptPubKey.end()));

            UniValue detail = DescribeAddress(dest);
            ret.pushKVs(detail);
        }
    }
    return ret;
}

static UniValue createmultisig(const Config &config,
                               const JSONRPCRequest &request) {
    if (request.fHelp || request.params.size() < 2 ||
        request.params.size() > 2) {
        std::string msg =
            RPCHelpMan{
                "createmultisig",
                "\nCreates a multi-signature address with n signature of m "
                "keys required.\n"
                "It returns a json object with the address and redeemScript.\n",
                {
                    {"nrequired", RPCArg::Type::NUM, RPCArg::Optional::NO,
                     "The number of required signatures out of the n keys."},
                    {"keys",
                     RPCArg::Type::ARR,
                     RPCArg::Optional::NO,
                     "A json array of hex-encoded public keys.",
                     {
                         {"key", RPCArg::Type::STR_HEX,
                          RPCArg::Optional::OMITTED,
                          "The hex-encoded public key"},
                     }},
                },
                RPCResult{"{\n"
                          "  \"address\":\"multisigaddress\",  (string) The "
                          "value of the new multisig address.\n"
                          "  \"redeemScript\":\"script\"       (string) The "
                          "string value of the hex-encoded redemption script.\n"
                          "}\n"},
                RPCExamples{
                    "\nCreate a multisig address from 2 public keys\n" +
                    HelpExampleCli(
                        "createmultisig",
                        "2 "
                        "\"["
                        "\\\"03789ed0bb717d88f7d321a368d905e7430207ebbd82bd3"
                        "42cf11ae157a7ace5fd\\\","
                        "\\\"03dbc6764b8884a92e871274b87583e6d5c2a58819473e1"
                        "7e107ef3f6aa5a61626\\\"]\"") +
                    "\nAs a JSON-RPC call\n" +
                    HelpExampleRpc(
                        "createmultisig",
                        "2, "
                        "\"["
                        "\\\"03789ed0bb717d88f7d321a368d905e7430207ebbd82bd3"
                        "42cf11ae157a7ace5fd\\\","
                        "\\\"03dbc6764b8884a92e871274b87583e6d5c2a58819473e1"
                        "7e107ef3f6aa5a61626\\\"]\"")},
            }
                .ToString();
        throw std::runtime_error(msg);
    }

    int required = request.params[0].get_int();

    // Get the public keys
    const UniValue &keys = request.params[1].get_array();
    std::vector<CPubKey> pubkeys;
    for (size_t i = 0; i < keys.size(); ++i) {
        if ((keys[i].get_str().length() ==
                 2 * CPubKey::COMPRESSED_PUBLIC_KEY_SIZE ||
             keys[i].get_str().length() == 2 * CPubKey::PUBLIC_KEY_SIZE) &&
            IsHex(keys[i].get_str())) {
            pubkeys.push_back(HexToPubKey(keys[i].get_str()));
        } else {
            throw JSONRPCError(
                RPC_INVALID_ADDRESS_OR_KEY,
                strprintf("Invalid public key: %s\n", keys[i].get_str()));
        }
    }

    // Get the output type
    OutputType output_type = OutputType::LEGACY;

    // Construct using pay-to-script-hash:
    const CScript inner = CreateMultisigRedeemscript(required, pubkeys);
    CBasicKeyStore keystore;
    const CTxDestination dest =
        AddAndGetDestinationForScript(keystore, inner, output_type);

    UniValue result(UniValue::VOBJ);
    result.pushKV("address", EncodeDestination(dest, config));
    result.pushKV("redeemScript", HexStr(inner.begin(), inner.end()));

    return result;
}

UniValue deriveaddresses(const Config &config, const JSONRPCRequest &request) {
    if (request.fHelp || request.params.empty() || request.params.size() > 3) {
        throw std::runtime_error(RPCHelpMan{
            "deriveaddresses",
            {"\nDerives one or more addresses corresponding to an output "
             "descriptor.\n"
             "Examples of output descriptors are:\n"
             "    pkh(<pubkey>)                        P2PKH outputs for the "
             "given pubkey\n"
             "    sh(multi(<n>,<pubkey>,<pubkey>,...)) P2SH-multisig outputs "
             "for the given threshold and pubkeys\n"
             "    raw(<hex script>)                    Outputs whose "
             "scriptPubKey equals the specified hex scripts\n"
             "\nIn the above, <pubkey> either refers to a fixed public key in "
             "hexadecimal notation, or to an xpub/xprv optionally followed by "
             "one\n"
             "or more path elements separated by \"/\", where \"h\" represents "
             "a hardened child key.\n"
             "For more information on output descriptors, see the "
             "documentation in the doc/descriptors.md file.\n"},
            {
                {"descriptor", RPCArg::Type::STR, RPCArg::Optional::NO,
                 "The descriptor."},
                {"begin", RPCArg::Type::NUM,
                 RPCArg::Optional::OMITTED_NAMED_ARG,
                 "If a ranged descriptor is used, this specifies the beginning "
                 "of the range to import."},
                {"end", RPCArg::Type::NUM, RPCArg::Optional::OMITTED_NAMED_ARG,
                 "If a ranged descriptor is used, this specifies the end of "
                 "the range to import."},
            },
            RPCResult{"[ address ] (array) the derived addresses\n"},
            RPCExamples{
                "First three native segwit receive addresses\n" +
                HelpExampleCli(
                    "deriveaddresses",
                    "\"pkh([d34db33f/84h/0h/"
                    "0h]"
                    "xpub6DJ2dNUysrn5Vt36jH2KLBT2i1auw1tTSSomg8PhqNiUtx8QX2SvC9"
                    "nrHu81fT41fvDUnhMjEzQgXnQjKEu3oaqMSzhSrHMxyyoEAmUHQbY/0/"
                    "*)\" 0 2")}}.ToString());
    }

    RPCTypeCheck(request.params,
                 {UniValue::VSTR, UniValue::VNUM, UniValue::VNUM});
    const std::string desc_str = request.params[0].get_str();

    int range_begin = 0;
    int range_end = 0;

    if (request.params.size() >= 2) {
        if (request.params.size() == 2) {
            throw JSONRPCError(RPC_INVALID_PARAMETER,
                               "Missing range end parameter");
        }
        range_begin = request.params[1].get_int();
        range_end = request.params[2].get_int();
        if (range_begin < 0) {
            throw JSONRPCError(RPC_INVALID_PARAMETER,
                               "Range should be greater or equal than 0");
        }
        if (range_begin > range_end) {
            throw JSONRPCError(
                RPC_INVALID_PARAMETER,
                "Range end should be equal to or greater than begin");
        }
    }

    FlatSigningProvider provider;
    auto desc = Parse(desc_str, provider);
    if (!desc) {
        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY,
                           strprintf("Invalid descriptor"));
    }

    if (!desc->IsRange() && request.params.size() > 1) {
        throw JSONRPCError(
            RPC_INVALID_PARAMETER,
            "Range should not be specified for an un-ranged descriptor");
    }

    if (desc->IsRange() && request.params.size() == 1) {
        throw JSONRPCError(RPC_INVALID_PARAMETER,
                           "Range must be specified for a ranged descriptor");
    }

    UniValue addresses(UniValue::VARR);

    for (int i = range_begin; i <= range_end; ++i) {
        std::vector<CScript> scripts;
        if (!desc->Expand(i, provider, scripts, provider)) {
            throw JSONRPCError(
                RPC_INVALID_ADDRESS_OR_KEY,
                strprintf("Cannot derive script without private keys"));
        }

        for (const CScript &script : scripts) {
            CTxDestination dest;
            if (!ExtractDestination(script, dest)) {
                throw JSONRPCError(
                    RPC_INVALID_ADDRESS_OR_KEY,
                    strprintf(
                        "Descriptor does not have a corresponding address"));
            }

            addresses.push_back(EncodeDestination(dest, config));
        }
    }

    // This should not be possible, but an assert seems overkill:
    if (addresses.empty()) {
        throw JSONRPCError(RPC_MISC_ERROR, "Unexpected empty result");
    }

    return addresses;
}

static UniValue verifymessage(const Config &config,
                              const JSONRPCRequest &request) {
    if (request.fHelp || request.params.size() != 3) {
        throw std::runtime_error(RPCHelpMan{
            "verifymessage",
            "\nVerify a signed message\n",
            {
                {"address", RPCArg::Type::STR, RPCArg::Optional::NO,
                 "The bitcoin address to use for the signature."},
                {"signature", RPCArg::Type::STR, RPCArg::Optional::NO,
                 "The signature provided by the signer in base 64 encoding "
                 "(see signmessage)."},
                {"message", RPCArg::Type::STR, RPCArg::Optional::NO,
                 "The message that was signed."},
            },
            RPCResult{"true|false   (boolean) If the signature is verified or "
                      "not.\n"},
            RPCExamples{
                "\nUnlock the wallet for 30 seconds\n" +
                HelpExampleCli("walletpassphrase", "\"mypassphrase\" 30") +
                "\nCreate the signature\n" +
                HelpExampleCli(
                    "signmessage",
                    "\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4XX\" \"my message\"") +
                "\nVerify the signature\n" +
                HelpExampleCli("verifymessage",
                               "\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4"
                               "XX\" \"signature\" \"my "
                               "message\"") +
                "\nAs a JSON-RPC call\n" +
                HelpExampleRpc("verifymessage",
                               "\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4"
                               "XX\", \"signature\", \"my "
                               "message\"")},
        }
                                     .ToString());
    }

    LOCK(cs_main);

    std::string strAddress = request.params[0].get_str();
    std::string strSign = request.params[1].get_str();
    std::string strMessage = request.params[2].get_str();

    CTxDestination destination =
        DecodeDestination(strAddress, config.GetChainParams());
    if (!IsValidDestination(destination)) {
        throw JSONRPCError(RPC_TYPE_ERROR, "Invalid address");
    }

    const CKeyID *keyID = boost::get<CKeyID>(&destination);
    if (!keyID) {
        throw JSONRPCError(RPC_TYPE_ERROR, "Address does not refer to key");
    }

    bool fInvalid = false;
    std::vector<uint8_t> vchSig = DecodeBase64(strSign.c_str(), &fInvalid);

    if (fInvalid) {
        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY,
                           "Malformed base64 encoding");
    }

    CHashWriter ss(SER_GETHASH, 0);
    ss << strMessageMagic;
    ss << strMessage;

    CPubKey pubkey;
    if (!pubkey.RecoverCompact(ss.GetHash(), vchSig)) {
        return false;
    }

    return (pubkey.GetID() == *keyID);
}

static UniValue signmessagewithprivkey(const Config &config,
                                       const JSONRPCRequest &request) {
    if (request.fHelp || request.params.size() != 2) {
        throw std::runtime_error(RPCHelpMan{
            "signmessagewithprivkey",
            "\nSign a message with the private key of an address\n",
            {
                {"privkey", RPCArg::Type::STR, RPCArg::Optional::NO,
                 "The private key to sign the message with."},
                {"message", RPCArg::Type::STR, RPCArg::Optional::NO,
                 "The message to create a signature of."},
            },
            RPCResult{"\"signature\"          (string) The signature of the "
                      "message encoded in base 64\n"},
            RPCExamples{"\nCreate the signature\n" +
                        HelpExampleCli("signmessagewithprivkey",
                                       "\"privkey\" \"my message\"") +
                        "\nVerify the signature\n" +
                        HelpExampleCli("verifymessage",
                                       "\"1D1ZrZNe3JUo7ZycKEYQQiQAWd9y54F4"
                                       "XX\" \"signature\" \"my "
                                       "message\"") +
                        "\nAs a JSON-RPC call\n" +
                        HelpExampleRpc("signmessagewithprivkey",
                                       "\"privkey\", \"my message\"")},
        }
                                     .ToString());
    }

    std::string strPrivkey = request.params[0].get_str();
    std::string strMessage = request.params[1].get_str();

    CKey key = DecodeSecret(strPrivkey);
    if (!key.IsValid()) {
        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid private key");
    }

    CHashWriter ss(SER_GETHASH, 0);
    ss << strMessageMagic;
    ss << strMessage;

    std::vector<uint8_t> vchSig;
    if (!key.SignCompact(ss.GetHash(), vchSig)) {
        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Sign failed");
    }

    return EncodeBase64(vchSig.data(), vchSig.size());
}

static UniValue setmocktime(const Config &config,
                            const JSONRPCRequest &request) {
    if (request.fHelp || request.params.size() != 1) {
        throw std::runtime_error(RPCHelpMan{
            "setmocktime",
            "\nSet the local time to given timestamp (-regtest only)\n",
            {
                {"timestamp", RPCArg::Type::NUM, RPCArg::Optional::NO,
                 "Unix seconds-since-epoch timestamp\n"
                 "   Pass 0 to go back to using the system time."},
            },
            RPCResults{},
            RPCExamples{""},
        }
                                     .ToString());
    }

    if (!config.GetChainParams().MineBlocksOnDemand()) {
        throw std::runtime_error(
            "setmocktime for regression testing (-regtest mode) only");
    }

    // For now, don't change mocktime if we're in the middle of validation, as
    // this could have an effect on mempool time-based eviction, as well as
    // IsInitialBlockDownload().
    // TODO: figure out the right way to synchronize around mocktime, and
    // ensure all call sites of GetTime() are accessing this safely.
    LOCK(cs_main);

    RPCTypeCheck(request.params, {UniValue::VNUM});
    int64_t mockTime = request.params[0].get_int64();
    if (mockTime < 0) {
        throw JSONRPCError(RPC_INVALID_PARAMETER,
                           "Timestamp must be 0 or greater");
    }
    SetMockTime(mockTime);

    return NullUniValue;
}

static UniValue RPCLockedMemoryInfo() {
    LockedPool::Stats stats = LockedPoolManager::Instance().stats();
    UniValue obj(UniValue::VOBJ);
    obj.pushKV("used", uint64_t(stats.used));
    obj.pushKV("free", uint64_t(stats.free));
    obj.pushKV("total", uint64_t(stats.total));
    obj.pushKV("locked", uint64_t(stats.locked));
    obj.pushKV("chunks_used", uint64_t(stats.chunks_used));
    obj.pushKV("chunks_free", uint64_t(stats.chunks_free));
    return obj;
}

#ifdef HAVE_MALLOC_INFO
static std::string RPCMallocInfo() {
    char *ptr = nullptr;
    size_t size = 0;
    FILE *f = open_memstream(&ptr, &size);
    if (f) {
        malloc_info(0, f);
        fclose(f);
        if (ptr) {
            std::string rv(ptr, size);
            free(ptr);
            return rv;
        }
    }
    return "";
}
#endif

static UniValue getmemoryinfo(const Config &config,
                              const JSONRPCRequest &request) {
    /* Please, avoid using the word "pool" here in the RPC interface or help,
     * as users will undoubtedly confuse it with the other "memory pool"
     */
    if (request.fHelp || request.params.size() > 1) {
        throw std::runtime_error(RPCHelpMan{
            "getmemoryinfo",
            "Returns an object containing information about memory usage.\n",
            {
                {"mode", RPCArg::Type::STR, /* default */ "\"stats\"",
                 "determines what kind of information is returned.\n"
                 "  - \"stats\" returns general statistics about memory usage "
                 "in the daemon.\n"
                 "  - \"mallocinfo\" returns an XML string describing "
                 "low-level heap state (only available if compiled with glibc "
                 "2.10+)."},
            },
            {
                RPCResult{"mode \"stats\"",
                          "{\n"
                          "  \"locked\": {               (json object) "
                          "Information about locked memory manager\n"
                          "    \"used\": xxxxx,          (numeric) Number of "
                          "bytes used\n"
                          "    \"free\": xxxxx,          (numeric) Number of "
                          "bytes available in current arenas\n"
                          "    \"total\": xxxxxxx,       (numeric) Total "
                          "number of bytes managed\n"
                          "    \"locked\": xxxxxx,       (numeric) Amount of "
                          "bytes that succeeded locking. If this number is "
                          "smaller than total, locking pages failed at some "
                          "point and key data could be swapped to disk.\n"
                          "    \"chunks_used\": xxxxx,   (numeric) Number "
                          "allocated chunks\n"
                          "    \"chunks_free\": xxxxx,   (numeric) Number "
                          "unused chunks\n"
                          "  }\n"
                          "}\n"},
                RPCResult{"mode \"mallocinfo\"",
                          "\"<malloc version=\"1\">...\"\n"},
            },
            RPCExamples{HelpExampleCli("getmemoryinfo", "") +
                        HelpExampleRpc("getmemoryinfo", "")},
        }
                                     .ToString());
    }

    std::string mode =
        request.params[0].isNull() ? "stats" : request.params[0].get_str();
    if (mode == "stats") {
        UniValue obj(UniValue::VOBJ);
        obj.pushKV("locked", RPCLockedMemoryInfo());
        return obj;
    } else if (mode == "mallocinfo") {
#ifdef HAVE_MALLOC_INFO
        return RPCMallocInfo();
#else
        throw JSONRPCError(
            RPC_INVALID_PARAMETER,
            "mallocinfo is only available when compiled with glibc 2.10+");
#endif
    } else {
        throw JSONRPCError(RPC_INVALID_PARAMETER, "unknown mode " + mode);
    }
}

static void EnableOrDisableLogCategories(UniValue cats, bool enable) {
    cats = cats.get_array();
    for (size_t i = 0; i < cats.size(); ++i) {
        std::string cat = cats[i].get_str();

        bool success;
        if (enable) {
            success = LogInstance().EnableCategory(cat);
        } else {
            success = LogInstance().DisableCategory(cat);
        }

        if (!success) {
            throw JSONRPCError(RPC_INVALID_PARAMETER,
                               "unknown logging category " + cat);
        }
    }
}

static UniValue logging(const Config &config, const JSONRPCRequest &request) {
    if (request.fHelp || request.params.size() > 2) {
        throw std::runtime_error(RPCHelpMan{
            "logging",
            "Gets and sets the logging configuration.\n"
            "When called without an argument, returns the list of categories "
            "with status that are currently being debug logged or not.\n"
            "When called with arguments, adds or removes categories from debug "
            "logging and return the lists above.\n"
            "The arguments are evaluated in order \"include\", \"exclude\".\n"
            "If an item is both included and excluded, it will thus end up "
            "being excluded.\n"
            "The valid logging categories are: " +
                ListLogCategories() +
                "\n"
                "In addition, the following are available as category names "
                "with special meanings:\n"
                "  - \"all\",  \"1\" : represent all logging categories.\n"
                "  - \"none\", \"0\" : even if other logging categories are "
                "specified, ignore all of them.\n",
            {
                {"include",
                 RPCArg::Type::ARR,
                 RPCArg::Optional::OMITTED_NAMED_ARG,
                 "A json array of categories to add debug logging",
                 {
                     {"include_category", RPCArg::Type::STR,
                      RPCArg::Optional::OMITTED, "the valid logging category"},
                 }},
                {"exclude",
                 RPCArg::Type::ARR,
                 RPCArg::Optional::OMITTED_NAMED_ARG,
                 "A json array of categories to remove debug logging",
                 {
                     {"exclude_category", RPCArg::Type::STR,
                      RPCArg::Optional::OMITTED, "the valid logging category"},
                 }},
            },
            RPCResult{"{                   (json object where keys are the "
                      "logging categories, and values indicates its status\n"
                      "  \"category\": 0|1,  (numeric) if being debug logged "
                      "or not. 0:inactive, 1:active\n"
                      "  ...\n"
                      "}\n"},
            RPCExamples{HelpExampleCli("logging",
                                       "\"[\\\"all\\\"]\" \"[\\\"http\\\"]\"") +
                        HelpExampleRpc("logging", "[\"all\"], \"[libevent]\"")},
        }
                                     .ToString());
    }

    uint32_t original_log_categories = LogInstance().GetCategoryMask();
    if (request.params[0].isArray()) {
        EnableOrDisableLogCategories(request.params[0], true);
    }

    if (request.params[1].isArray()) {
        EnableOrDisableLogCategories(request.params[1], false);
    }

    uint32_t updated_log_categories = LogInstance().GetCategoryMask();
    uint32_t changed_log_categories =
        original_log_categories ^ updated_log_categories;

    /**
     * Update libevent logging if BCLog::LIBEVENT has changed.
     * If the library version doesn't allow it, UpdateHTTPServerLogging()
     * returns false, in which case we should clear the BCLog::LIBEVENT flag.
     * Throw an error if the user has explicitly asked to change only the
     * libevent flag and it failed.
     */
    if (changed_log_categories & BCLog::LIBEVENT) {
        if (!UpdateHTTPServerLogging(
                LogInstance().WillLogCategory(BCLog::LIBEVENT))) {
            LogInstance().DisableCategory(BCLog::LIBEVENT);
            if (changed_log_categories == BCLog::LIBEVENT) {
                throw JSONRPCError(RPC_INVALID_PARAMETER,
                                   "libevent logging cannot be updated when "
                                   "using libevent before v2.1.1.");
            }
        }
    }

    UniValue result(UniValue::VOBJ);
    std::vector<CLogCategoryActive> vLogCatActive = ListActiveLogCategories();
    for (const auto &logCatActive : vLogCatActive) {
        result.pushKV(logCatActive.category, logCatActive.active);
    }

    return result;
}

static UniValue echo(const Config &config, const JSONRPCRequest &request) {
    if (request.fHelp) {
        throw std::runtime_error(RPCHelpMan{
            "echo|echojson ...",
            "\nSimply echo back the input arguments. This command is for "
            "testing.\n"
            "\nThe difference between echo and echojson is that echojson has "
            "argument conversion enabled in the client-side table in "
            "bitcoin-cli and the GUI. There is no server-side difference.",
            {},
            RPCResults{},
            RPCExamples{""},
        }
                                     .ToString());
    }

    CHECK_NONFATAL(request.params.size() != 100);

    return request.params;
}

bool getAddressFromIndex(const int &type, const uint160 &hash, std::string &address)
{
    if (type == 2) {
        address = CBitcoinAddress(CScriptID(hash)).ToString();
    } else if (type == 1) {
        address = CBitcoinAddress(CKeyID(hash)).ToString();
    } else {
        return false;
    }
    return true;
}

bool getAddressesFromParams(const UniValue& params, std::vector<std::pair<uint160, int> > &addresses)
{
    if (params[0].isStr()) {
        CTxDestination dest = DecodeDestination(params[0].get_str(), Params());
        bool isValid = IsValidDestination(dest);
        if (!isValid) {
            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid address");
        }
        CBitcoinAddress address(EncodeLegacyAddr(dest, Params()));
        uint160 hashBytes;
        int type = 0;
        if (!address.GetIndexKey(hashBytes, type)) {
            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid address");
        }
        addresses.push_back(std::make_pair(hashBytes, type));
    } else if (params[0].isObject()) {

        UniValue addressValues = find_value(params[0].get_obj(), "addresses");
        if (!addressValues.isArray()) {
            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Addresses is expected to be an array");
        }

        std::vector<UniValue> values = addressValues.getValues();

        for (std::vector<UniValue>::iterator it = values.begin(); it != values.end(); ++it) {

            CTxDestination dest = DecodeDestination(it->get_str(), Params());
            bool isValid = IsValidDestination(dest);
            if (!isValid) {
                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid address");
            }
            CBitcoinAddress address(EncodeLegacyAddr(dest, Params()));
            uint160 hashBytes;
            int type = 0;
            if (!address.GetIndexKey(hashBytes, type)) {
                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid address");
            }
            addresses.push_back(std::make_pair(hashBytes, type));
        }
    } else {
        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid address");
    }

    return true;
}

bool heightSort(std::pair<CAddressUnspentKey, CAddressUnspentValue> a,
                std::pair<CAddressUnspentKey, CAddressUnspentValue> b) {
    return a.second.blockHeight < b.second.blockHeight;
}

bool timestampSort(std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> a,
                   std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> b) {
    return a.second.time < b.second.time;
}

UniValue getaddressmempool(const Config &config, const JSONRPCRequest& request)
{
    if (request.fHelp || request.params.size() != 1)
        throw std::runtime_error(
            "getaddressmempool\n"
            "\nReturns all mempool deltas for an address (requires addressindex to be enabled).\n"
            "\nArguments:\n"
            "{\n"
            "  \"addresses\"\n"
            "    [\n"
            "      \"address\"  (string) The base58check encoded address\n"
            "      ,...\n"
            "    ]\n"
            "}\n"
            "\nResult:\n"
            "[\n"
            "  {\n"
            "    \"address\"  (string) The base58check encoded address\n"
            "    \"txid\"  (string) The related txid\n"
            "    \"index\"  (number) The related input or output index\n"
            "    \"satoshis\"  (number) The difference of satoshis\n"
            "    \"timestamp\"  (number) The time the transaction entered the mempool (seconds)\n"
            "    \"prevtxid\"  (string) The previous txid (if spending)\n"
            "    \"prevout\"  (string) The previous transaction output index (if spending)\n"
            "  }\n"
            "]\n"
            "\nExamples:\n"
            + HelpExampleCli("getaddressmempool", "'{\"addresses\": [\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\"]}'")
            + HelpExampleRpc("getaddressmempool", "{\"addresses\": [\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\"]}")
        );

    std::vector<std::pair<uint160, int> > addresses;

    if (!getAddressesFromParams(request.params, addresses)) {
        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid address");
    }

    std::vector<std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> > indexes;

    if (!g_mempool.getAddressIndex(addresses, indexes)) {
        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "No information available for address");
    }

    std::sort(indexes.begin(), indexes.end(), timestampSort);

    UniValue result(UniValue::VARR);

    for (std::vector<std::pair<CMempoolAddressDeltaKey, CMempoolAddressDelta> >::iterator it = indexes.begin();
         it != indexes.end(); it++) {

        std::string address;
        if (!getAddressFromIndex(it->first.type, it->first.addressBytes, address)) {
            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Unknown address type");
        }

        UniValue delta(UniValue::VOBJ);
        delta.push_back(Pair("address", address));
        delta.push_back(Pair("txid", it->first.txhash.GetHex()));
        delta.push_back(Pair("index", (int)it->first.index));
        delta.push_back(Pair("satoshis", it->second.amount));
        delta.push_back(Pair("timestamp", it->second.time));
        if (it->second.amount < 0) {
            delta.push_back(Pair("prevtxid", it->second.prevhash.GetHex()));
            delta.push_back(Pair("prevout", (int)it->second.prevout));
        }
        result.push_back(delta);
    }

    return result;
}

UniValue getaddressutxos(const Config &config, const JSONRPCRequest& request)
{
    if (request.fHelp || request.params.size() != 1)
        throw std::runtime_error(
            "getaddressutxos\n"
            "\nReturns all unspent outputs for an address (requires addressindex to be enabled).\n"
            "\nArguments:\n"
            "{\n"
            "  \"addresses\"\n"
            "    [\n"
            "      \"address\"  (string) The base58check encoded address\n"
            "      ,...\n"
            "    ],\n"
            "  \"chainInfo\"  (boolean) Include chain info with results\n"
            "}\n"
            "\nResult\n"
            "[\n"
            "  {\n"
            "    \"address\"  (string) The address base58check encoded\n"
            "    \"txid\"  (string) The output txid\n"
            "    \"height\"  (number) The block height\n"
            "    \"outputIndex\"  (number) The output index\n"
            "    \"script\"  (strin) The script hex encoded\n"
            "    \"satoshis\"  (number) The number of satoshis of the output\n"
            "  }\n"
            "]\n"
            "\nExamples:\n"
            + HelpExampleCli("getaddressutxos", "'{\"addresses\": [\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\"]}'")
            + HelpExampleRpc("getaddressutxos", "{\"addresses\": [\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\"]}")
            );

    bool includeChainInfo = false;
    if (request.params[0].isObject()) {
        UniValue chainInfo = find_value(request.params[0].get_obj(), "chainInfo");
        if (chainInfo.isBool()) {
            includeChainInfo = chainInfo.get_bool();
        }
    }

    std::vector<std::pair<uint160, int> > addresses;

    if (!getAddressesFromParams(request.params, addresses)) {
        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid address");
    }

    std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> > unspentOutputs;

    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {
        if (!GetAddressUnspent((*it).first, (*it).second, unspentOutputs)) {
            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "No information available for address");
        }
    }

    std::sort(unspentOutputs.begin(), unspentOutputs.end(), heightSort);

    UniValue utxos(UniValue::VARR);

    for (std::vector<std::pair<CAddressUnspentKey, CAddressUnspentValue> >::const_iterator it=unspentOutputs.begin(); it!=unspentOutputs.end(); it++) {
        UniValue output(UniValue::VOBJ);
        std::string address;
        if (!getAddressFromIndex(it->first.type, it->first.hashBytes, address)) {
            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Unknown address type");
        }

        output.push_back(Pair("address", address));
        output.push_back(Pair("txid", it->first.txhash.GetHex()));
        output.push_back(Pair("outputIndex", (int)it->first.index));
        output.push_back(Pair("script", HexStr(it->second.script.begin(), it->second.script.end())));
        output.push_back(Pair("satoshis", it->second.satoshis));
        output.push_back(Pair("height", it->second.blockHeight));
        utxos.push_back(output);
    }

    if (includeChainInfo) {
        UniValue result(UniValue::VOBJ);
        result.push_back(Pair("utxos", utxos));

        LOCK(cs_main);
        result.push_back(Pair("hash", chainActive.Tip()->GetBlockHash().GetHex()));
        result.push_back(Pair("height", (int)chainActive.Height()));
        return result;
    } else {
        return utxos;
    }
}

UniValue getaddressdeltas(const Config &config, const JSONRPCRequest& request)
{
    if (request.fHelp || request.params.size() != 1 || !request.params[0].isObject())
        throw std::runtime_error(
            "getaddressdeltas\n"
            "\nReturns all changes for an address (requires addressindex to be enabled).\n"
            "\nArguments:\n"
            "{\n"
            "  \"addresses\"\n"
            "    [\n"
            "      \"address\"  (string) The base58check encoded address\n"
            "      ,...\n"
            "    ]\n"
            "  \"start\" (number) The start block height\n"
            "  \"end\" (number) The end block height\n"
            "  \"chainInfo\" (boolean) Include chain info in results, only applies if start and end specified\n"
            "}\n"
            "\nResult:\n"
            "[\n"
            "  {\n"
            "    \"satoshis\"  (number) The difference of satoshis\n"
            "    \"txid\"  (string) The related txid\n"
            "    \"index\"  (number) The related input or output index\n"
            "    \"height\"  (number) The block height\n"
            "    \"address\"  (string) The base58check encoded address\n"
            "  }\n"
            "]\n"
            "\nExamples:\n"
            + HelpExampleCli("getaddressdeltas", "'{\"addresses\": [\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\"]}'")
            + HelpExampleRpc("getaddressdeltas", "{\"addresses\": [\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\"]}")
        );


    UniValue startValue = find_value(request.params[0].get_obj(), "start");
    UniValue endValue = find_value(request.params[0].get_obj(), "end");

    UniValue chainInfo = find_value(request.params[0].get_obj(), "chainInfo");
    bool includeChainInfo = false;
    if (chainInfo.isBool()) {
        includeChainInfo = chainInfo.get_bool();
    }

    int start = 0;
    int end = 0;

    if (startValue.isNum() && endValue.isNum()) {
        start = startValue.get_int();
        end = endValue.get_int();
        if (start <= 0 || end <= 0) {
            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Start and end is expected to be greater than zero");
        }
        if (end < start) {
            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "End value is expected to be greater than start");
        }
    }

    std::vector<std::pair<uint160, int> > addresses;

    if (!getAddressesFromParams(request.params, addresses)) {
        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid address");
    }

    std::vector<std::pair<CAddressIndexKey, CAmount> > addressIndex;

    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {
        if (start > 0 && end > 0) {
            if (!GetAddressIndex((*it).first, (*it).second, addressIndex, start, end)) {
                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "No information available for address");
            }
        } else {
            if (!GetAddressIndex((*it).first, (*it).second, addressIndex)) {
                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "No information available for address");
            }
        }
    }

    UniValue deltas(UniValue::VARR);

    for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=addressIndex.begin(); it!=addressIndex.end(); it++) {
        std::string address;
        if (!getAddressFromIndex(it->first.type, it->first.hashBytes, address)) {
            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Unknown address type");
        }

        UniValue delta(UniValue::VOBJ);
        delta.push_back(Pair("satoshis", it->second));
        delta.push_back(Pair("txid", it->first.txhash.GetHex()));
        delta.push_back(Pair("index", (int)it->first.index));
        delta.push_back(Pair("blockindex", (int)it->first.txindex));
        delta.push_back(Pair("height", it->first.blockHeight));
        delta.push_back(Pair("address", address));
        deltas.push_back(delta);
    }

    UniValue result(UniValue::VOBJ);

    if (includeChainInfo && start > 0 && end > 0) {
        LOCK(cs_main);

        if (start > chainActive.Height() || end > chainActive.Height()) {
            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Start or end is outside chain range");
        }

        CBlockIndex* startIndex = chainActive[start];
        CBlockIndex* endIndex = chainActive[end];

        UniValue startInfo(UniValue::VOBJ);
        UniValue endInfo(UniValue::VOBJ);

        startInfo.push_back(Pair("hash", startIndex->GetBlockHash().GetHex()));
        startInfo.push_back(Pair("height", start));

        endInfo.push_back(Pair("hash", endIndex->GetBlockHash().GetHex()));
        endInfo.push_back(Pair("height", end));

        result.push_back(Pair("deltas", deltas));
        result.push_back(Pair("start", startInfo));
        result.push_back(Pair("end", endInfo));

        return result;
    } else {
        return deltas;
    }
}

UniValue getaddressbalance(const Config &config, const JSONRPCRequest& request)
{
    if (request.fHelp || request.params.size() != 1)
        throw std::runtime_error(
            "getaddressbalance\n"
            "\nReturns the balance for an address(es) (requires addressindex to be enabled).\n"
            "\nArguments:\n"
            "{\n"
            "  \"addresses\"\n"
            "    [\n"
            "      \"address\"  (string) The base58check encoded address\n"
            "      ,...\n"
            "    ]\n"
            "}\n"
            "\nResult:\n"
            "{\n"
            "  \"balance\"  (string) The current balance in satoshis\n"
            "  \"received\"  (string) The total number of satoshis received (including change)\n"
            "}\n"
            "\nExamples:\n"
            + HelpExampleCli("getaddressbalance", "'{\"addresses\": [\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\"]}'")
            + HelpExampleRpc("getaddressbalance", "{\"addresses\": [\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\"]}")
        );

    std::vector<std::pair<uint160, int> > addresses;

    if (!getAddressesFromParams(request.params, addresses)) {
        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid address");
    }

    std::vector<std::pair<CAddressIndexKey, CAmount> > addressIndex;

    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {
        if (!GetAddressIndex((*it).first, (*it).second, addressIndex)) {
            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "No information available for address");
        }
    }

    CAmount balance = 0;
    CAmount received = 0;

    for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=addressIndex.begin(); it!=addressIndex.end(); it++) {
        if (it->second > 0) {
            received += it->second;
        }
        balance += it->second;
    }

    UniValue result(UniValue::VOBJ);
    result.push_back(Pair("balance", balance));
    result.push_back(Pair("received", received));

    return result;

}

UniValue getaddresstxids(const Config &config, const JSONRPCRequest& request)
{
    if (request.fHelp || request.params.size() != 1)
        throw std::runtime_error(
            "getaddresstxids\n"
            "\nReturns the txids for an address(es) (requires addressindex to be enabled).\n"
            "\nArguments:\n"
            "{\n"
            "  \"addresses\"\n"
            "    [\n"
            "      \"address\"  (string) The base58check encoded address\n"
            "      ,...\n"
            "    ]\n"
            "  \"start\" (number) The start block height\n"
            "  \"end\" (number) The end block height\n"
            "}\n"
            "\nResult:\n"
            "[\n"
            "  \"transactionid\"  (string) The transaction id\n"
            "  ,...\n"
            "]\n"
            "\nExamples:\n"
            + HelpExampleCli("getaddresstxids", "'{\"addresses\": [\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\"]}'")
            + HelpExampleRpc("getaddresstxids", "{\"addresses\": [\"12c6DSiU4Rq3P4ZxziKxzrL5LmMBrzjrJX\"]}")
        );

    std::vector<std::pair<uint160, int> > addresses;

    if (!getAddressesFromParams(request.params, addresses)) {
        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid address");
    }

    int start = 0;
    int end = 0;
    if (request.params[0].isObject()) {
        UniValue startValue = find_value(request.params[0].get_obj(), "start");
        UniValue endValue = find_value(request.params[0].get_obj(), "end");
        if (startValue.isNum() && endValue.isNum()) {
            start = startValue.get_int();
            end = endValue.get_int();
        }
    }

    std::vector<std::pair<CAddressIndexKey, CAmount> > addressIndex;

    for (std::vector<std::pair<uint160, int> >::iterator it = addresses.begin(); it != addresses.end(); it++) {
        if (start > 0 && end > 0) {
            if (!GetAddressIndex((*it).first, (*it).second, addressIndex, start, end)) {
                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "No information available for address");
            }
        } else {
            if (!GetAddressIndex((*it).first, (*it).second, addressIndex)) {
                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "No information available for address");
            }
        }
    }

    std::set<std::pair<int, std::string> > txids;
    UniValue result(UniValue::VARR);

    for (std::vector<std::pair<CAddressIndexKey, CAmount> >::const_iterator it=addressIndex.begin(); it!=addressIndex.end(); it++) {
        int height = it->first.blockHeight;
        std::string txid = it->first.txhash.GetHex();

        if (addresses.size() > 1) {
            txids.insert(std::make_pair(height, txid));
        } else {
            if (txids.insert(std::make_pair(height, txid)).second) {
                result.push_back(txid);
            }
        }
    }

    if (addresses.size() > 1) {
        for (std::set<std::pair<int, std::string> >::const_iterator it=txids.begin(); it!=txids.end(); it++) {
            result.push_back(it->second);
        }
    }

    return result;

}

UniValue getspentinfo(const Config &config, const JSONRPCRequest& request)
{

    if (request.fHelp || request.params.size() != 1 || !request.params[0].isObject())
        throw std::runtime_error(
            "getspentinfo\n"
            "\nReturns the txid and index where an output is spent.\n"
            "\nArguments:\n"
            "{\n"
            "  \"txid\" (string) The hex string of the txid\n"
            "  \"index\" (number) The start block height\n"
            "}\n"
            "\nResult:\n"
            "{\n"
            "  \"txid\"  (string) The transaction id\n"
            "  \"index\"  (number) The spending input index\n"
            "  ,...\n"
            "}\n"
            "\nExamples:\n"
            + HelpExampleCli("getspentinfo", "'{\"txid\": \"0437cd7f8525ceed2324359c2d0ba26006d92d856a9c20fa0241106ee5a597c9\", \"index\": 0}'")
            + HelpExampleRpc("getspentinfo", "{\"txid\": \"0437cd7f8525ceed2324359c2d0ba26006d92d856a9c20fa0241106ee5a597c9\", \"index\": 0}")
        );

    UniValue txidValue = find_value(request.params[0].get_obj(), "txid");
    UniValue indexValue = find_value(request.params[0].get_obj(), "index");

    if (!txidValue.isStr() || !indexValue.isNum()) {
        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Invalid txid or index");
    }

    uint256 txid = ParseHashV(txidValue, "txid");
    int outputIndex = indexValue.get_int();

    CSpentIndexKey key(txid, outputIndex);
    CSpentIndexValue value;

    if (!GetSpentIndex(key, value)) {
        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, "Unable to get spent info");
    }

    UniValue obj(UniValue::VOBJ);
    obj.push_back(Pair("txid", value.txid.GetHex()));
    obj.push_back(Pair("index", (int)value.inputIndex));
    obj.push_back(Pair("height", value.blockHeight));

    return obj;
}

// clang-format off
static const CRPCCommand commands[] = {
    //  category            name                      actor (function)        argNames
    //  ------------------- ------------------------  ----------------------  ----------
    { "control",            "getmemoryinfo",          getmemoryinfo,          {"mode"} },
    { "control",            "logging",                logging,                {"include", "exclude"} },
    { "util",               "validateaddress",        validateaddress,        {"address"} },
    { "util",               "createmultisig",         createmultisig,         {"nrequired","keys"} },
    { "util",               "deriveaddresses",        deriveaddresses,        {"descriptor", "begin", "end"} },
    { "util",               "verifymessage",          verifymessage,          {"address","signature","message"} },
    { "util",               "signmessagewithprivkey", signmessagewithprivkey, {"privkey","message"} },

    /* Address index */
    { "addressindex",       "getaddressmempool",      getaddressmempool,      {} },
    { "addressindex",       "getaddressutxos",        getaddressutxos,        {} },
    { "addressindex",       "getaddressdeltas",       getaddressdeltas,       {} },
    { "addressindex",       "getaddressbalance",      getaddressbalance,      {} },
    { "addressindex",       "getaddresstxids",        getaddresstxids,        {} },

    /* Blockchain */
    { "blockchain",         "getspentinfo",           getspentinfo,           {} },

    /* Not shown in help */
    { "hidden",             "setmocktime",            setmocktime,            {"timestamp"}},
    { "hidden",             "echo",                   echo,                   {"arg0","arg1","arg2","arg3","arg4","arg5","arg6","arg7","arg8","arg9"}},
    { "hidden",             "echojson",               echo,                   {"arg0","arg1","arg2","arg3","arg4","arg5","arg6","arg7","arg8","arg9"}},
};
// clang-format on

void RegisterMiscRPCCommands(CRPCTable &t) {
    for (unsigned int vcidx = 0; vcidx < ARRAYLEN(commands); vcidx++) {
        t.appendCommand(commands[vcidx].name, &commands[vcidx]);
    }
}
